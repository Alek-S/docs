//
//  pathfinder.js
//

var pathfinder = exports;

var fs = require('fs'),
    path = require('path'),
    mkdirp = require('mkdirp'),
    traverse = require('traverse'),
    findit = require('findit');

//
// Transform array into flat object
// Uses as a helper.
//
var filesArrayToObject = function(files, resolve){
  var _files = {};
  files.forEach(function(file){
    var contents = '';
    if (resolve) {
      //
      // Remark: also read the contents of the file
      // and set it in memory on JSON object as binary data
      //
      var stat = fs.statSync(file);

      if (stat.isDirectory()) {
        contents = { "isDirectory": true };
      } else {
        contents = fs.readFileSync(file);
      }

    }
    _files[file] = contents;
  });
  return _files;
}


//
// Recursively read directory into flat JSON object
// arguments: path, resolve, filter
//
pathfinder.readDir = function (p, resolve, filter, cb) {

  if (!filter) {
    cb = resolve;
    resolve = false;
  } else if (!cb) {
    cb = filter;
    filter = null;
  }


  var files = [];

  // finder.find doesn't "do" errors-to-cb
  try {
    var finder = findit.find(p, function (f) {
      files.push(f);
    });

    finder.on("end", function () {
      if (typeof filter === 'function') {
        files = files.filter(filter);
      }

      cb(null, filesArrayToObject(files, resolve));

    });
  } catch (e) {
    cb(e);
  }
};


// Syncronous version of above.
pathfinder.readDirSync = function (p, resolve, filter) {

   var files = findit.sync(p);

   if( typeof filter === 'function') {
     //
     // Apply the fileMap method to the contents of each file 
     //
     files = files.filter(filter);
   }

   return filesArrayToObject(files, resolve);

};

// same as readDir but for single files.
pathfinder.readFile = function (p, resolve, filter, cb) {

  if (!filter) {
    cb = resolve;
    resolve = false;
  } else if (!cb) {
    cb = filter;
    filter = null;
  }

  fs.sync(p, function (stat) {
    if (!stat.isFile()) {
      cb(new Error("Path "+p+" must be a file!"));
    } else {
      if( typeof filter === 'function') {
        p = ([p].filter(filter))[0];
      }

      cb(null, filesArrayToObject([p], resolve));
    }
       
  });
}

// syncronous version of above.
pathfinder.readFileSync = function (p, resolve, filter) {
   if (!fs.statSync(p).isFile()) {
       throw new Error("Path "+p+" must be a file!");
   }

   if( typeof filter === 'function') {
     p = ([p].filter(filter))[0];
   }

   return filesArrayToObject([p], resolve);

}

//
// Forces a file write by using mkdirp to recurisvely build directories 
//
pathfinder.writeFile = function(filePath, contents, callback) {

  var fileDir = path.dirname(filePath);
  
  mkdirp(fileDir, 0755, function(err){
    if(err){
      callback(err);
    }
    fs.writeFile(filePath, contents, callback);
  });

};
